package JVA.ACM.面试;

import java.util.Arrays;
import java.util.Scanner;

public class MiHaYo {
    //题目描述:黑塔是一个喜欢转圈圈的女孩子。有一天，黑塔遇到了几个怪物，第i个怪物的生命值为h由于被守护者之影禁用了普通攻击，黑塔现在只能使用E技能攻击敌人。具体地说，黑塔每次使用E技能，会对敌方全体造成E点伤害。除此之外，每当一个怪物的生命值首次减小到其最大生命值的50%及以下(含50%)时，如果敌方尚有怪物存活(生命值大于零)，那么黑塔就会自动释放一次追加攻击“转圈圈”，对敌方全体造成R点伤害。如果一次攻击同时使多个敌人满足以上条件，那么黑塔也会连续释放多次“转圈圈”，直到“转圈圈”次数耗尽或者敌人全部倒下为止。在“转圈圈”结束之前，黑塔无法再次使用E技能。作为天才俱乐部#83的天才，黑塔只用了0.0114514秒就算出了自己需要使用多少次E技能才能击败这些怪物，以及在这个过程中她会释放多少次“转圈圈”。她觉得这个问题太简单了于是将其留给了你作为课后习题
    //输入描述:第一行一个正整数T，表示有T组数据。对于每一组数据，第一行一个正整数n，表示怪物的数量;第二行n个正整数h,h……h表示每个怪物的生命值;第三行两个正整数ER，分别表示黑塔E技能的伤害和“转圈圈”的伤害。1<=n<=10',1<=T<=10,1<=h E,R<=109
    //输出描述:对于每一组数据，输出一行两个正整数cntE,cntR,分别表示黑塔使用E技能的次数和“转圈的次数
    //输入
    // 3
    // 5
    // 100 50 60 80 70
    // 25 10
    // 5
    // 100 50 60 80 70
    // 20 20
    // 5
    // 100 200 300 4000 5000
    // 50 1000
    // 输出
    // 2 5
    // 2 3
    // 1 5
//     对于第一组数据:
// 初始怪物生命值为[100,50,60,80,70];黑塔使用E技能，怪物生命值变为[75,25,35,55,45];怪物2生命值小于等于50%，触发一次转圈圈，怪物生命值变为[65,15,25,45.35];
// 怪物3,5生命值小于等于50%，触发两次转圈圈，生命值变为[45,0,5,25,15];
// 怪物1,4触发两次转圈圈，生命值变为[25,0,0,5.0];使用E技能，生命值变为[0,0,0,0,0]，战斗结束，一共使用2次E，5次转圈圈。
// 对于第二组数据:
// 初始怪物生命值为[100,50,60,80,70];黑塔使用E技能，怪物生命值变为[80,30,40,60,50];再次使用E,生命值变为[60,10,20,40,30];怪物2,3,4,5触发四次转圈圈，但是只转3次所有怪物就全部被击杀，因此一共使用2次E，3次转图圈。
// 对于第三组数据:初始生命值为[100,200,300,4000,5000]使用E技能，[50,150,250,3950,4950]怪物1触发一次转圈圈，[0,0,0,2950,3950]怪物2，3触发两次转圈圈，[0,0,0,950,1950]怪物4，5触发两次转圈圈，[0,0,0,0.0]，战斗结束，一共使用1次E，5次转圈圈。
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int T = sc.nextInt();
    while (T-- > 0) {
        int n = sc.nextInt(); 
        int[] h = new int[n];
        for (int i = 0; i < n; i++) {
            h[i] = sc.nextInt();
        }
        int E = sc.nextInt(), R = sc.nextInt();
        int cntE = 0, cntR = 0;

        boolean allDead = false;
        while (!allDead) {
            allDead = true;
            boolean[] triggered = new boolean[n]; 
            for (int i = 0; i < n; i++) {
                if (h[i] > 0) {
                    allDead = false;
                    h[i] -= E;
                    if (h[i] <= 0) h[i] = 0;
                    else if (h[i] <= h[i] / 2) triggered[i] = true;
                }
            }
            if (!allDead) cntE++;

            for (int i = 0; i < n; i++) {
                if (triggered[i]) {
                    for (int j = 0; j < n; j++) {
                        if (h[j] > 0) {
                            h[j] -= R;
                            if (h[j] <= 0) h[j] = 0;
                        }
                    }
                    cntR++; 
                }
            }
        }

        System.out.println(cntE + " " + cntR);
    }
}
    // 题目：坐标的（0,0）到（x1,y1）构成一个矩形，计算（x2,y2)落入矩形的可能性。
    // 输入：第一行的m和n表示数组a和b的长度，第二行是数组a，第三行是数组b。给定一个长度为n的整数序列a，和一个长度为m的整数序列6，从a中选择其中一个数字作为x，从b中选择一个数字作为y，这样可以得到一组坐标(x,y)，x1y1和x2y2都客户已通过上述办法产生
    // 输入例子：
    // 3 3
    // 1 2 3
    // 1 1 3
    // 输出例子：
    // 42
    // 提示：当整整选择的位置是(1，1)，岁阳选择的位置是(1，3)时，藿藿无法成功捉拿岁阳。当藿藿选择的位置是(2，3)，岁阳选择的位置是(2，1)时，整整可以成功捉拿岁阳。类似的情况共有 42种，因此输出42。
public static void main2(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        long[] a = new long[m];
        long[] b = new long[n];

        for (int i = 0; i < m; i++) {
            a[i] = sc.nextLong();
        }
        for (int i = 0; i < n; i++) {
            b[i] = sc.nextLong();
        }

        // 对a和b进行排序
        Arrays.sort(a);
        Arrays.sort(b);

        long count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 由于数组已经排序，使用二分搜索快速找到小于等于a[i]的b中元素的数量
                int pos = Arrays.binarySearch(b, a[i]);
                if (pos < 0) { // 如果没有找到，binarySearch返回的是 -(插入点) - 1
                    pos = -pos - 2; // 转换为插入点的前一个位置，即最后一个小于a[i]的元素的位置
                }
                count += pos + 1; // +1因为索引从0开始，需要转换为数量
            }
        }

        System.out.println(count);
    }
    // 2.
    // 题目：在潜入下层工厂后，蓬菜寺九雪在其中一个房间中发现了N(1≤N≤5000)台机器。这些机器排成一排，从左到右依次编号为1、2、…、N。且每台机器都有一个能量值，编号为i的机,器的能量值为a;(-1012≤a;≤1012)。现在蓬菜寺九雪想要启动其中一些机器。在简单尝试后，她发现若两台启动的机器之间没有其他任何其他启动的机器，则这两台机器会尝试连接:但是若一台机器左右两边都有机器尝试与其连接，且左右两台机器能量值的平均值大于等于中间这台机器的能量值，则会使得中间的机器系统崩溃现在所有的机器都已恢复关机状态，九霄想知道的是，在不引发机器系统崩溃的情况下，最多可以同时启动多少台机器?
    // 输入：输入的第一行包括一个整数N，表示机器的数量。第二行包括N个整数 a1、à2、… aN，表示这 N台机器的能量值。
    // 输出：输出一行一个整数表示答案
    // 输入例子：
    // 5
    // 1 2 3 2 1
    // 输出例子：
    // 4
//     样例解释
// 在这一情景中，蓬莱寺九霄可以选择启动编号为1、2、4、5 的机器。
    public static void main3(String[] args){
        Scanner sc = new Scanner(System.in);
        
        int N = sc.nextInt();
        long[] a = new long[N];
        for (int i = 0; i < N; i++) {
            a[i] = sc.nextLong();
        }

        int[] dp = new int[N];
        int max = 1;
        dp[0] = 1; 
        for (int i = 1; i < N; i++) {
            dp[i] = 1; 
            for (int j = 0; j < i; j++) {
                if (a[j] < a[i] && dp[j] + 1 > dp[i]) { 
                    dp[i] = dp[j] + 1;
                }
            }
            max = Math.max(max, dp[i]); 
        }

        System.out.println(max);
    }
}
